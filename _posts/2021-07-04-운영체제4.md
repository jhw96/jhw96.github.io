---
layout: post
title: '운영체제 개요4(데드락, 경쟁 상태)'
categories: [cs]
tags: [interview, cs]
---

## 1. 데드락(DeadLock) : 교착 상태

- 프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

* 데드락이 발생하는 경우
  <br>
  <img src="https://user-images.githubusercontent.com/57614563/124382148-e49a7b80-dd00-11eb-9188-92d7bc15cee3.PNG" width="60%">

1. 프로세스 A는 Resource 1을 사용 중, 프로세스 B가 사용중인 Resource 2를 사용하기 위해 대기
2. 프로세스 B는 Resource 2을 사용 중, 프로세스 A가 사용중인 Resource 1을 사용하기 위해 대기
   -> 프로세스 A, B 둘 다 사용중인 Resource를 잡고, 다른 프로세스가 사용 중인 Resource 사용 대기 중

##### \* 현재 서로 원하는 자원을 상대방이 사용하고 있어서 두 프로세스는 무한정 Wait 상태 -> DeadLock

### \* 데드락 발생 조건

- 4가지 조건이 모두 성립해야 발생한다. 하나라도 성립되지 않으면 교착 상태 탈출 가능

1. 상호 배제(Mutual exclusion) : 자원은 한번에 한 프로세스만 사용 가능.

2. 점유 대기(Hold and wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 한다.

3. 비선점(No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.

4. 순환 대기(Circular wait) : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

### \* 데드락 해결 방법

#### 1) 예방(Prevention) : 교착 상태가 생길 조건을 없애는 것(4가지 조건 중 하나를 부정)

1-1) **상호배제** 부정 : 여러 프로세스가 공유 자원 사용 **but 애초에 자원들은 근본적으로 공유가 불가**해서 상호배제 조건 부정은 어렵다.
<br>
1-2) **점유대기** 부정 : 프로세스 실행 전 모든 자원을 할당 **but 자원의 효율성이 많이 떨어진다.**
<br>
1-3) **비선점** 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납 but 이미 실행한 작업의 상태를 잃어버릴 수도 있다.
<br>
1-4) **순환대기** 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
<br>

#### 2) 회피(Avoidance) : 교착 상태의 발생 가능성을 배제하지 않고 적절히 회피

ex) 은행원 알고리즘(Banker's Algorithm)

- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
- 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

#### 3) 탐지(Dectection) : 교착 상태를 허용하지만 교착 상태를 탐지하고 다시 회복하는 방법

-> **탐지 알고리즘**을 이용해서 현재 시스템이 교착상태인지 판별 후, 교착상태라면 이를 회복해야한다.

#### \* 회복(Recovery)

3-1) 순환 대기를 깨트리기 위해 단순히 한 개 이상의 스레드를 중지시키는 방법
-> 교착 상태에 빠진 모든 프로세스를 중단시키는 방법
-> 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법

3-2) 교착 상태에 있는 하나 이상의 스레드로부터 자원을 선점하는 것

#### 4) 무시 : 그냥 무시하고 오히려 교착상태를 해결하는 것보다 부딪히는게 비용이 덜 들때 사용

## 2. 경쟁 상태(Race Condition) : 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

-> 동시 접근 시 자료의 일관성을 해치는 결과가 나타날 수 있다.

### \* 경쟁 상태가 발생하는 경우

#### 1. 커널 작업을 수행하는 중에 인터럽트(Interrupt) 발생

-> 커널 안에 있는 변수를 증가시는 중 인터럽트가 발생하여 인터럽트 처리 함수에서는 해당 변수를 감소시킬 때 변수의 결과값에 문제가 발생(인터럽트별 처리 함수의 코드는 커널에 존재함)

- 해결법 : 작업을 할 때 인터럽트 발생하더라도 작업이 완료된 후 인터럽트가 발생하도록 처리순서를 부여

#### 2. 프로세스가 System Call을 하여 커널 모드로 진입하여 작업을 수행 중일 때 Context Switch가 발생할 때

- 해결법 : 사용자 프로세스가 System Call을 호출하여 커널모드의 작업을 완료한 후 Context Switch가 발생할 수 있게 한다. **(커널모드에 있다면 CPU의 제어권을 빼앗지 않음!)**

#### 3. 여러 프로세스의 공유 메모리 내 커널 안 변수에 접근하는 케이스

-> CPU가 여러 개인 시스템에서 공유 메모리 속 데이터를 여러 프로세스가 접근할 때 발생하는 케이스

- 해결법 : 커널 안 변수에 접근할 때 lock/unlock을 걸어 **매 순간 변수에 접근하는 프로세스는 오직 1개**로 한정한다.
